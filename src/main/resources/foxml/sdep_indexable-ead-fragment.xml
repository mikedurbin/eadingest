<?xml version="1.0" encoding="UTF-8"?>
<foxml:digitalObject VERSION="1.1" PID="sdep:indexable-ead-fragment"
  xmlns:foxml="info:fedora/fedora-system:def/foxml#"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="info:fedora/fedora-system:def/foxml# http://www.fedora.info/definitions/1/0/foxml1-1.xsd">
  <foxml:objectProperties>
    <foxml:property NAME="info:fedora/fedora-system:def/model#state" VALUE="Active"/>
  </foxml:objectProperties>
  <foxml:datastream ID="DC" STATE="A" CONTROL_GROUP="X" VERSIONABLE="true">
    <foxml:datastreamVersion ID="DC1.0" LABEL="Dublin Core Record for this object"
      MIMETYPE="text/xml" FORMAT_URI="http://www.openarchives.org/OAI/2.0/oai_dc/">
      <foxml:xmlContent>
        <oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/"
          xmlns:dc="http://purl.org/dc/elements/1.1/"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd">
          <dc:identifier>sdep:indexable-ead-fragment</dc:identifier>
        </oai_dc:dc>
      </foxml:xmlContent>
    </foxml:datastreamVersion>
  </foxml:datastream>
  <foxml:datastream ID="RELS-EXT" STATE="A" CONTROL_GROUP="X" VERSIONABLE="true">
    <foxml:datastreamVersion ID="RELS-EXT.0" LABEL="" MIMETYPE="application/rdf+xml">
      <foxml:xmlContent>
        <rdf:RDF xmlns:fedora-model="info:fedora/fedora-system:def/model#"
          xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
          <rdf:Description rdf:about="info:fedora/sdep:indexable-ead-fragment">
            <fedora-model:hasModel rdf:resource="info:fedora/fedora-system:ServiceDeployment-3.0"/>
            <fedora-model:hasModel rdf:resource="info:fedora/cmodel:documented-mapping"/>
            <fedora-model:isDeploymentOf rdf:resource="info:fedora/sdef:indexable"/>
            <fedora-model:isContractorOf rdf:resource="info:fedora/cmodel:ead-root"/>
            <fedora-model:isContractorOf rdf:resource="info:fedora/cmodel:ead-component"/>
          </rdf:Description>
        </rdf:RDF>
      </foxml:xmlContent>
    </foxml:datastreamVersion>
  </foxml:datastream>
  <foxml:datastream ID="METHODMAP" STATE="A" CONTROL_GROUP="X" VERSIONABLE="true">
    <foxml:datastreamVersion ID="METHODMAP.0" LABEL="" MIMETYPE="text/xml">
      <foxml:xmlContent>
        <fmm:MethodMap xmlns:fmm="http://fedora.comm.nsdlib.org/service/methodmap" name="N/A">
          <fmm:method operationName="getIndexingMetadata" wsdlMsgName="getIndexingMetadataRequest"
            wsdlMsgOutput="getIndexingMetadataResponse">
            <fmm:DefaultInputParm defaultValue="$pid" parmName="pid" passBy="VALUE" required="TRUE"/>
            <fmm:DatastreamInputParm parmName="descMetadata" passBy="URL_REF" required="true"/>
            <fmm:MethodReturnType wsdlMsgName="getIndexingMetadataResponse" wsdlMsgTOMIME="N/A"/>
          </fmm:method>
        </fmm:MethodMap>
      </foxml:xmlContent>
    </foxml:datastreamVersion>
  </foxml:datastream>
  <foxml:datastream ID="WSDL" STATE="A" CONTROL_GROUP="X" VERSIONABLE="true">
    <foxml:datastreamVersion ID="WSDL.0" LABEL="" MIMETYPE="text/xml">
      <foxml:xmlContent>
        <wsdl:definitions xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"
          xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/"
          xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap"
          xmlns:soapenc="http://schemas.xmlsoap.org/wsdl/soap/encoding"
          xmlns:this="urn:thisNamespace" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
          xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="N/A"
          targetNamespace="urn:thisNamespace">
          <wsdl:types>
            <xsd:schema targetNamespace="urn:thisNamespace">
              <xsd:simpleType name="inputType">
                <xsd:restriction base="xsd:string"/>
              </xsd:simpleType>
              <xsd:simpleType name="pidType">
                <xsd:restriction base="xsd:string"/>
              </xsd:simpleType>
            </xsd:schema>
          </wsdl:types>
          <wsdl:message name="getIndexingMetadataRequest">
            <wsdl:part name="pid" type="this:pidType"/>
            <wsdl:part name="descMetadata" type="this:inputType"/>
          </wsdl:message>
          <wsdl:message name="getIndexingMetadataResponse">
            <wsdl:part name="response" type="xsd:element"/>
          </wsdl:message>
          <wsdl:portType name="portType">
            <wsdl:operation name="getIndexingMetadata">
              <wsdl:input message="this:getIndexingMetadataRequest"/>
              <wsdl:output message="this:getIndexingMetadataResponse"/>
            </wsdl:operation>
          </wsdl:portType>
          <wsdl:service name="N/A">
            <wsdl:port binding="this:binding" name="port">
              <http:address location="LOCAL"/>
            </wsdl:port>
          </wsdl:service>
          <wsdl:binding name="binding" type="this:portType">
            <http:binding verb="GET"/>
            <wsdl:operation name="getIndexingMetadata">
              <http:operation
                location="http://local.fedora.server/saxon/SaxonServlet?source=(descMetadata)&amp;style=http://local.fedora.server/fedora/get/sdep:indexable-ead-fragment/XSLT&amp;pid=(pid)&amp;clear-stylesheet-cache=yes"/>
              <wsdl:input>
                <http:urlReplacement/>
              </wsdl:input>
              <wsdl:output>
                <mime:content type="N/A"/>
              </wsdl:output>
            </wsdl:operation>
          </wsdl:binding>
        </wsdl:definitions>
      </foxml:xmlContent>
    </foxml:datastreamVersion>
  </foxml:datastream>
  <foxml:datastream ID="DSINPUTSPEC" STATE="A" CONTROL_GROUP="X" VERSIONABLE="true">
    <foxml:datastreamVersion ID="DSINPUTSPEC.0" LABEL="" MIMETYPE="text/xml">
      <foxml:xmlContent>
        <fbs:DSInputSpec xmlns:fbs="http://fedora.comm.nsdlib.org/service/bindspec" label="N/A">
          <fbs:DSInput DSMax="1" DSMin="1" DSOrdinality="false" wsdlMsgPartName="descMetadata">
            <fbs:DSInputLabel>descMetadata</fbs:DSInputLabel>
            <fbs:DSMIME>text/xml</fbs:DSMIME>
            <fbs:DSInputInstruction>N/A</fbs:DSInputInstruction>
          </fbs:DSInput>
        </fbs:DSInputSpec>
      </foxml:xmlContent>
    </foxml:datastreamVersion>
  </foxml:datastream>
  <foxml:datastream ID="XSLT" STATE="A" CONTROL_GROUP="X" VERSIONABLE="true">
    <foxml:datastreamVersion ID="XSLT.0" LABEL="" MIMETYPE="text/xml">
      <foxml:xmlContent>
<!--
   - An XSLT that takes descriptive metadata in either MODS or EAD-fragment
   - form, along with a fedora PID and builds a SOLR index that contains
   - the information directly from that record as well as from all records
   - related to the given PID hierarchically.  
  -->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:s="http://www.w3.org/2001/sw/DataAccess/rf1/result"
    xmlns:marc="http://www.loc.gov/MARC21/slim"
    xmlns:doc="http://www.oxygenxml.com/ns/doc/xsl"
    xmlns:mapping="http://lib.virginia.edu/mapping"
    xmlns:apia="http://www.fedora.info/definitions/1/0/access/"
    exclude-result-prefixes="xs s marc doc mapping apia"
    version="2.0">

    <!-- 
        A URL of a simple mapping from the ISO 639.2 language codes to the
        human readable name 
    -->
    <xsl:variable name="iso6392">
        <xsl:text>http://localhost:8080/fedora/objects/vocab:iso639.2/datastreams/XML/content</xsl:text>
    </xsl:variable>

    <xsl:output byte-order-mark="no" encoding="UTF-8" media-type="text/xml" xml:space="preserve" indent="yes"/>
    
    <xsl:variable name="fedora-host">localhost</xsl:variable>
    <xsl:param name="pid" />
    <xsl:param name="debug" />
    
    <xsl:variable name="currentPid"><xsl:value-of select="$pid" /></xsl:variable>
    
    <xsl:template match="*" priority="-1" mode="primary" />
    <xsl:template match="*" priority="-1" mode="subsequent" />
    <xsl:template match="*" priority="-1" mode="marc" />

    <doc:doc>
        <doc:desc>
            <doc:p>
                This matches the root of the MODS document and outputs a corresponding SOLR add document.
                This transformation was written for the Holsinger Stuido Collection and makes assumptions
                about the structure of the incoming MODS document that may be unsuitable for other materials.
            </doc:p>
            <doc:p>
                The following solr fields are automatically populated:
                <doc:ul>
                    <doc:li mapping:type="solrField" mapping:sourceXPath="$pid">id</doc:li>
                    <doc:li mapping:type="solrField" mapping:sourceXPath="'cmodel:ead-component'">content_model_facet</doc:li>
                    <doc:li mapping:type="solrField" mapping:sourceXPath="'UVA Library Digital Repository'">source_facet</doc:li>
                    <doc:li mapping:type="solrField" mapping:sourceXPath="'Special Collections'">library_facet</doc:li>
                    <doc:li mapping:type="solrField" mapping:sourceXPath="'Special Collections'">location_facet</doc:li>
                </doc:ul>
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="/">
        <add>
            <doc>
                <field name="id"><xsl:value-of select="$pid"/></field>
                <field name="source_facet">UVA Library Digital Repository</field>
                
                <!-- pull some information from fedora for:
                    date_received_facet 
                    content_model_facet 
                -->
                <xsl:variable name="objectProfile" select="document(concat('http://', $fedora-host, ':8080/fedora/objects/', $pid, '?format=xml'))" />
                <xsl:for-each select="$objectProfile/apia:objectProfile/apia:objModels/apia:model">
                    <xsl:if test="not(starts-with(current(), 'info:fedora/fedora-system'))">
                        <field name="content_model_facet"><xsl:value-of select="substring(text(), string-length('info:fedora/') + 1)" /></field>
                    </xsl:if>
                </xsl:for-each>
                <xsl:variable name="createDate" select="$objectProfile/apia:objectProfile/apia:objCreateDate/text()" />
                <field name="date_received_facet">
                    <xsl:value-of select="concat(substring($createDate, 1, 4), substring($createDate, 6, 2), substring($createDate, 9, 2))" />
                </field> 

                <xsl:apply-templates select="//*" mode="primary" />
                
                <xsl:variable name="ancestors">
                    <xsl:call-template name="get-ancestry">
                        <xsl:with-param name="pid" select="$pid" />
                    </xsl:call-template>
                </xsl:variable>
                
                <xsl:call-template name="index-ancestors">
                    <xsl:with-param name="ancestors" select="$ancestors" />
                </xsl:call-template>
                    
                <!-- Add the breadcrumbs display -->
                <field name="breadcrumbs_display">
                    <xsl:text>&lt;breadcrumbs&gt;</xsl:text>
                    <xsl:for-each select="$ancestors/ancestor">
                        <xsl:text>&lt;id&gt;</xsl:text><xsl:value-of select="pid" /><xsl:text>&lt;/id&gt;</xsl:text>
                        
                        <xsl:variable name="title">
                            <xsl:choose>
                                <xsl:when test="current()//ead/frontmatter/titlepage/titleproper">
                                    <xsl:for-each select="current()//ead/frontmatter/titlepage/titleproper//text()">
                                        <xsl:value-of select="current()" />
                                    </xsl:for-each>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:for-each select="current()//did/unittitle//text()">
                                        <xsl:value-of select="current()" />
                                    </xsl:for-each>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:variable>
                        
                        <xsl:text>&lt;title&gt;</xsl:text>
                        <xsl:value-of select="$title" />
                        <xsl:text>&lt;/title&gt;</xsl:text>
                    </xsl:for-each>
                    <xsl:text>&lt;/breadcrumbs&gt;</xsl:text>
                </field>
                
                <!-- Add the hierarchy display -->
                <field name="hierarchy_display">
                    <xsl:value-of select="unparsed-text(concat('http://', $fedora-host, ':8080/fedora/objects/', $pid, '/methods/sdef:hierarchical-metadata/getSummary'))" />
                </field>
                <field name="full_hierarchy_display">
                    <xsl:value-of select="unparsed-text(concat('http://', $fedora-host, ':8080/fedora/objects/', $pid, '/methods/sdef:hierarchical-metadata/getFullSummary'))" />
                </field>
            </doc>
        </add>
    </xsl:template>
    
    <xsl:variable name="lowercase" select="'abcdefghijklmnopqrstuvwxyz '"/>
    <xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ-,;:.'"/>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">repository_name_display</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="/ead/archdesc/did/repository" mode="#all">
        <field name="repository_name_display">
            <xsl:value-of select="normalize-space(text())"></xsl:value-of>
        </field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">call_number_display</doc:li>
                <doc:li mapping:type="solrField">call_number_facet</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="/ead/archdesc/did/unitid" mode="#all">
        <field name="call_number_facet"><xsl:value-of select="normalize-space(text())" /></field>
        <field name="call_number_display"><xsl:value-of select="normalize-space(text())" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">creator_display</doc:li>
                <doc:li mapping:type="solrField">author_facet</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="datafield[@tag='100']/subfield[@code='a']" mode="marc">
        <xsl:variable name="creator">
            <xsl:if test="ends-with(text(), ',')">
                <xsl:value-of select="substring(text(), 1, string-length(text()) - 1)" />
            </xsl:if>
            <xsl:if test="not(ends-with(text(), ','))">
                <xsl:value-of select="text()" />
            </xsl:if>
        </xsl:variable>
        <field name="creator_display">
            <xsl:value-of select="$creator"></xsl:value-of>
        </field>
        <field name="author_facet">
            <xsl:value-of select="$creator"></xsl:value-of>
        </field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField" mapping:sourceXPath="'More than 50 years ago'">published_date_facet</doc:li>
                <doc:li mapping:type="solrField">date_display</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="unitdate" mode="primary">
        <field name="date_display">
            <xsl:value-of select="text()" />
        </field>
        <!--
            We'll have to parse out the date into something structured
        
        <field name="year_multisort_i">
            
        </field>
        -->
        <!-- this is hard-coded for now -->
        <field name="published_date_facet">
            <xsl:text>More than 50 years ago</xsl:text>
        </field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">main_title_display</doc:li>
                <doc:li mapping:type="solrField">title_text</doc:li>
                <doc:li mapping:type="solrField">digital_collection_facet</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="/ead/archdesc/did/unittitle" mode="primary">
        <xsl:variable name="title">
            <xsl:for-each select="descendant-or-self::node()">
                <xsl:value-of select="text()" />
            </xsl:for-each>
        </xsl:variable>
        <field name="main_title_display" boost="2.0"><xsl:value-of select="normalize-space($title)" /></field>
        <field name="title_text"><xsl:value-of select="normalize-space($title)"></xsl:value-of></field>
        <field name="digital_collection_facet"><xsl:value-of select="normalize-space($title)" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">collection_title_display</doc:li>
                <doc:li mapping:type="solrField">digital_collection_facet</doc:li>
                <doc:li mapping:type="solrField">collection_title_text</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="/ead/archdesc/did/unittitle" mode="subsequent">
        <xsl:variable name="title">
            <xsl:for-each select="descendant-or-self::node()">
                <xsl:value-of select="text()" />
            </xsl:for-each>
        </xsl:variable>
        <field name="collection_title_display"><xsl:value-of select="normalize-space($title)" /></field>
        <field name="digital_collection_facet"><xsl:value-of select="normalize-space($title)" /></field>
        <field name="collection_title_text" boost="0.25"><xsl:value-of select="normalize-space($title)"></xsl:value-of></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">library_facet</doc:li>
                <doc:li mapping:type="solrField">location_facet</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="filedesc/publicationstmt/publisher" mode="primary subsequent">
        <field name="library_facet">
            <xsl:value-of select="normalize-space(text())" />
        </field>
        <field name="location_facet">
            <xsl:value-of select="normalize-space(text())" />
        </field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">scope_content_display</doc:li>
                <doc:li mapping:type="solrField">scope_content_text</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="scopecontent" mode="primary">
        <xsl:variable name="content">
            <xsl:for-each select="descendant-or-self::node()">
                <xsl:value-of select="text()" />
            </xsl:for-each>
        </xsl:variable>
        <field name="scope_content_display">
            <xsl:value-of select="normalize-space($content)" />
        </field>
        <field name="scope_content_text"><xsl:value-of select="normalize-space($content)" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">extent_display</doc:li>
                <doc:li mapping:type="solrField">extent_text</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="physdesc[@label='Extent' or @label='extent']" mode="primary">
        <field name="extent_display"><xsl:value-of select="text()" /></field>
        <field name="extent_text"><xsl:value-of select="text()" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField">collection_abstract_display</doc:li>
                <doc:li mapping:type="solrField">colleciton_abstract_text</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="abstract" mode="#all">
        <xsl:variable name="abstract">
            <xsl:for-each select="descendant-or-self::node()">
                <xsl:value-of select="text()" />
            </xsl:for-each>
        </xsl:variable>
        <field name="collection_abstract_display" boost="0.5"><xsl:value-of select="normalize-space($abstract)" /></field>
        <field name="collection_abstract_text" boost="0.5"><xsl:value-of select="normalize-space($abstract)" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                This template matches any did/physdec with the text value of 'Map'and 
                builds the <doc:b mapping:type="solrField">format_facet</doc:b> and 
                <doc:b mapping:type="solrField">format_text</doc:b> SOLR fields from
                the various nested elements. 
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="did/physdesc[text() = 'MAP']" mode="primary">
        <field name="format_facet">Map</field>
        <field name="format_text">Map</field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                This template matches any did/langmaterial/language with the text value of 'Map'and 
                builds the <doc:b mapping:type="solrField">language_facet</doc:b> SOLR field from
                the english rendering of the language specified by the given language code.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="did/langmaterial/language/@langcode" mode="primary">
        <xsl:if test="not(current()='zxx')">
            <xsl:variable name="languageCodeMapping" select="document($iso6392)" />
            <field name="language_facet">
                <xsl:value-of select="$languageCodeMapping/languages/language/english[../code/text()=current()]" />
            </field>
        </xsl:if>
        <field name="language_facet">Map</field>
        <field name="format_text">Map</field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                This template matches any userestrict elements to populate the 
                the <doc:b mapping:type="solrField">access_display</doc:b> and 
                <doc:b mapping:type="solrField">access_text</doc:b> SOLR fields from
                the various nested elements. 
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="userestrict" mode="primary">
        <field name="access_display"><xsl:value-of select="head" /><xsl:text>: </xsl:text><xsl:value-of select="p" /></field>
        <field name="access_text"><xsl:value-of select="head" /><xsl:text>: </xsl:text><xsl:value-of select="p" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                This template matches any accessestrict elements to populate the 
                the <doc:b mapping:type="solrField">access_display</doc:b> and 
                <doc:b mapping:type="solrField">access_text</doc:b> SOLR fields from
                the various nested elements. 
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="accessrestrict" mode="primary">
        <field name="access_display"><xsl:value-of select="head" /><xsl:text>: </xsl:text><xsl:value-of select="p" /></field>
        <field name="access_text"><xsl:value-of select="head" /><xsl:text>: </xsl:text><xsl:value-of select="p" /></field>
    </xsl:template>
    
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                Maps the unittitle to the following SOLR fields:
                <doc:ul>
                    <doc:li mapping:type="solrField">main_title_display</doc:li>
                    <doc:li mapping:type="solrField">title_text</doc:li>
                    <doc:li mapping:type="full_title_text">full_title_text</doc:li>
                </doc:ul>
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="unittitle" mode="primary">
        <xsl:variable name="title">
            <xsl:for-each select="descendant-or-self::node()">
                <xsl:value-of select="text()" />
            </xsl:for-each>
        </xsl:variable>
        <field name="main_title_display"><xsl:value-of select="normalize-space($title)" /></field>
        <field name="title_text"><xsl:value-of select="normalize-space($title)" /></field>
        <field name="full_title_text"><xsl:value-of select="normalize-space($title)" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                Stores the ead id attribute to the 
                <doc:b mapping:type="solrField" mapping:sourceXPath="ead/@id">ead_id_text</doc:b> field.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="ead" mode="primary">
        <xsl:if test="@id">
            <field name="ead_id_text" boost="2.0"><xsl:value-of select="@id" /></field>
        </xsl:if>
        <xsl:if test="$debug">
            <xsl:comment>Matched EAD</xsl:comment>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="ead" mode="subsequent">
        <xsl:if test="@id">
            <field name="ead_id_text" boost="0.25"><xsl:value-of select="@id" /></field>
        </xsl:if>
        <xsl:if test="$debug">
            <xsl:comment>Matched EAD</xsl:comment>
        </xsl:if>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p mapping:type="solrField" mapping:sourceXPath="node()[starts-with(name(), 'c0')]/@level">hierarchy_level_facet</doc:p>
            <doc:p mapping:type="solrField" mapping:sourceXPath="node()[starts-with(name(), 'c0')]/@level">format_facet</doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="node()[starts-with(name(), 'c0')]" mode="primary">
        <xsl:if test="$debug">
            <xsl:comment>Matched <xsl:value-of select="name()" /></xsl:comment>
        </xsl:if>
        <field name="hierarchy_level_facet"><xsl:value-of select="@level" /></field>
        <field name="format_facet"><xsl:value-of select="@level" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField" mapping:sourceXPath="'collection">hierarchy_level_facet</doc:li>
                <doc:li mapping:type="solrField" mapping:sourceXPath="'Collection">format_facet</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template match="ead" mode="primary">
        <field name="hierarchy_level_facet">collection</field>
        <field name="format_facet">Collection</field>
    </xsl:template>   

    <!--
    <doc:doc>
        <doc:desc>
            <doc:p mapping:type="solrField" mapping:sourceXPath="node()[starts-with(name(), 'c0')]/did/unittitle">c0x_title_display</doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="node()[starts-with(name(), 'c0')]" mode="subsequent">
        <xsl:if test="$debug">
            <xsl:comment>Matched <xsl:value-of select="name()" /></xsl:comment>
        </xsl:if>
        <xsl:variable name="title">
            <xsl:for-each select="did/unittitle/descendant-or-self::node()">
                <xsl:value-of select="text()" />
            </xsl:for-each>
        </xsl:variable>
        <field>
            <xsl:attribute name="name">
                <xsl:value-of select="name()" />
                <xsl:text>_title_display</xsl:text>
            </xsl:attribute>
            <xsl:value-of select="normalize-space($title)" />
        </field>
    </xsl:template>
    -->
    
    <xsl:template match="marc:record" mode="marc">
        <xsl:if test="$debug">
            <xsl:comment>Matched MARC record</xsl:comment>
        </xsl:if>
    </xsl:template>

    <doc:doc>
        <doc:desc>
            <doc:p>
                When indexing the whole collection, this matches all personal names in marc
                records and stores them in the 
                <doc:b mapping:type="solrField">personal_name_display</doc:b> and
                <doc:b mapping:type="solrField">personal_name_text</doc:b> SOLR fields.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="marc:record/marc:datafield[@tag='600']/marc:subfield[@code='a']" mode="primary">
        <field name="personal_name_display"><xsl:value-of select="text()" /></field>
        <field name="personal_name_text"><xsl:value-of select="text()" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                When indexing the whole collection, this matches all corporate names in marc
                records and stores them in the 
                <doc:b mapping:type="solrField">corporate_name_display</doc:b> and
                <doc:b mapping:type="solrField">corporate_name_text</doc:b> SOLR fields.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="marc:record/marc:datafield[@tag='610']/marc:subfield[@code='a']" mode="primary">
        <field name="corporate_name_display"><xsl:value-of select="text()" /></field>
        <field name="corporate_name_text"><xsl:value-of select="text()" /></field>
    </xsl:template>

    <doc:doc>
        <doc:desc>
            <doc:p>
                When indexing the whole collection, this matches all personal names in marc
                records and stores them in the 
                <doc:b mapping:type="solrField">meeting_name_display</doc:b> and
                <doc:b mapping:type="solrField">meeting_name_text</doc:b> SOLR fields.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="marc:record/marc:datafield[@tag='611']/marc:subfield[@code='a']" mode="primary">
        <field name="meeting_name_display"><xsl:value-of select="text()" /></field>
        <field name="meeting_name_text"><xsl:value-of select="text()" /></field>
    </xsl:template>

    <doc:doc>
        <doc:desc>
            <doc:p>
                When indexing the whole collection, this matches all topics in marc
                records and stores them in the 
                <doc:b mapping:type="solrField">subject_facet</doc:b> and
                <doc:b mapping:type="solrField">subject_text</doc:b> SOLR fields.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="marc:record/marc:datafield[@tag='650']/marc:subfield[@code='a']" mode="primary">
        <field name="subject_facet"><xsl:value-of select="text()" /></field>
        <field name="subject_text"><xsl:value-of select="text()" /></field>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:p>
                When indexing the whole collection, this matches all index terms for
                genre in marc records and stores them in the 
                <doc:b mapping:type="solrField">genre_text</doc:b> and
                <doc:b mapping:type="solrField">genre_display</doc:b> SOLR fields.
            </doc:p>
        </doc:desc>
    </doc:doc>
    <xsl:template match="marc:record/marc:datafield[@tag='655']/marc:subfield[@code='a']" mode="primary">
        <field name="genre_display"><xsl:value-of select="text()" /></field>
        <field name="genre_text"><xsl:value-of select="text()" /></field>
    </xsl:template>




    <!--
        A recursive template to build an XML fragment that contains
        the metadata records for the objects that are the parent
        (and ancestors) of the object whose pid is passed to this
        template.
    -->
    <xsl:template name="get-ancestry">
        <xsl:param name="pid" />
        <xsl:variable name="lookupParentUri">
            <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host" /><xsl:text>:8080/fedora/risearch?type=tuples&amp;lang=itql&amp;format=Sparql&amp;query=select%20%24parentUri%20from%20%3C%23ri%3E%20%0Awhere%20%3Cinfo%3Afedora%2F</xsl:text>
            <xsl:value-of select="$pid" />
            <xsl:text>%3E%20%3Cinfo%3Afedora%2Ffedora-system%3Adef%2Frelations-external%23isPartOf%3E%20%24parentUri</xsl:text>
        </xsl:variable>
        <xsl:if test="$debug">
            <xsl:comment>
                Querying for related metadata from pid  <xsl:value-of select="$pid" /> using query: <xsl:value-of select="$lookupParentUri" />
            </xsl:comment>
        </xsl:if>
        <xsl:variable name="sparqlResult" select="document($lookupParentUri)" />
        <xsl:variable name="parentPid" select="substring($sparqlResult/s:sparql/s:results/s:result/s:parentUri/@uri, 13)"/>
        <xsl:if test="$parentPid">
            
            <xsl:call-template name="get-ancestry">
                <xsl:with-param name="pid" select="$parentPid"/>
            </xsl:call-template>
            
            <xsl:if test="$debug">
                <xsl:comment>Pulling metadata from <xsl:value-of select="$parentPid" /></xsl:comment>
            </xsl:if>
            <xsl:variable name="parentMetadataUrl">
                <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host" /><xsl:text>:8080/fedora/objects/</xsl:text>
                <xsl:value-of select="$parentPid" />
                <xsl:text>/datastreams/descMetadata/content</xsl:text>
            </xsl:variable>
            <xsl:variable name="parentDescMetadata" select="document($parentMetadataUrl)" />
            
            <ancestor>
                <pid><xsl:value-of select="$parentPid" /></pid>
                <xmlcontent>
                    <xsl:copy-of select="$parentDescMetadata" />
                </xmlcontent>
            </ancestor>
        </xsl:if>
    </xsl:template>


    <xsl:template name="index-ancestors">
        <xsl:param name="ancestors" required="yes" />
        
        <xsl:for-each select="$ancestors/ancestor">
            <xsl:variable name="pid" select="pid" />
            
            <!-- TODO: check for relationships to holdings records and index those too-->
            
            <!-- check for marc record and index them as well -->
            <xsl:variable name="lookupMarcUri">
                <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host"></xsl:value-of><xsl:text>:8080/fedora/risearch?type=tuples&amp;lang=itql&amp;format=Sparql&amp;query=select%20%24marcUri%20from%20%3C%23ri%3E%20%0Awhere%20%24marcUri%20%3Chttp%3A%2F%2Ffedora.lib.virginia.edu%2Frelationship%23hasHoldingRecordsFor%3E%20%3Cinfo%3Afedora%2F</xsl:text>
                <xsl:value-of select="$pid" />
                <xsl:text>%3E</xsl:text>
            </xsl:variable>
            <xsl:if test="$debug">
                <xsl:comment>
                    Querying for related MARC metadata from pid  <xsl:value-of select="$pid" /> using query: <xsl:value-of select="$lookupMarcUri" />
                </xsl:comment>
            </xsl:if>
            <xsl:variable name="marcSparqlResult" select="document($lookupMarcUri)" />
            <xsl:for-each select="$marcSparqlResult/s:sparql/s:results/s:result/s:marcUri/@uri">
                <xsl:variable name="marcPid" select="substring(current(), 13)" />
                <xsl:if test="$debug">
                    <xsl:comment>Pulling MARC metadata from <xsl:value-of select="$marcPid" /></xsl:comment>
                </xsl:if>
                <xsl:variable name="marcMetadataUrl">
                    <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host" /><xsl:text>:8080/fedora/objects/</xsl:text>
                    <xsl:value-of select="$marcPid" />
                    <xsl:text>/datastreams/descMetadata/content</xsl:text>
                </xsl:variable>
                <xsl:variable name="parentMarcMetadata" select="document($marcMetadataUrl)" />
                
                <xsl:apply-templates select="$parentMarcMetadata//*" mode="marc" />
            </xsl:for-each>
            
            <xsl:apply-templates select="current()/xmlcontent//*" mode="subsequent" />
            
        </xsl:for-each>
    </xsl:template>
    
    <doc:doc>
        <doc:desc>
            <doc:ul>
                <doc:li mapping:type="solrField" mapping:sourceXPath="[pid of record parsed]">c0x_pid_display</doc:li>
                <doc:li mapping:type="solrField" mapping:sourceXPath="[pid of record parsed]">collection_pid_display</doc:li>
            </doc:ul>
        </doc:desc>
    </doc:doc>
    <xsl:template name="index-parent">
        <xsl:param name="pid" required="yes" />
        
        <!-- TODO: check for relationships to holdings records and index those too-->
        
        <!-- check for marc record and index them as well -->
        <xsl:variable name="lookupMarcUri">
                <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host"></xsl:value-of><xsl:text>:8080/fedora/risearch?type=tuples&amp;lang=itql&amp;format=Sparql&amp;query=select%20%24marcUri%20from%20%3C%23ri%3E%20%0Awhere%20%24marcUri%20%3Chttp%3A%2F%2Ffedora.lib.virginia.edu%2Frelationship%23hasHoldingRecordsFor%3E%20%3Cinfo%3Afedora%2F</xsl:text>
                <xsl:value-of select="$pid" />
            <xsl:text>%3E</xsl:text>
        </xsl:variable>
        <xsl:if test="$debug">
            <xsl:comment>
                Querying for related MARC metadata from pid  <xsl:value-of select="$pid" /> using query: <xsl:value-of select="$lookupMarcUri" />
            </xsl:comment>
        </xsl:if>
        <xsl:variable name="marcSparqlResult" select="document($lookupMarcUri)" />
        <xsl:for-each select="$marcSparqlResult/s:sparql/s:results/s:result/s:marcUri/@uri">
            <xsl:variable name="marcPid" select="substring(current(), 13)" />
            <xsl:if test="$debug">
                <xsl:comment>Pulling MARC metadata from <xsl:value-of select="$marcPid" /></xsl:comment>
            </xsl:if>
            <xsl:variable name="marcMetadataUrl">
                <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host" /><xsl:text>:8080/fedora/objects/</xsl:text>
                <xsl:value-of select="$marcPid" />
                <xsl:text>/datastreams/descMetadata/content</xsl:text>
            </xsl:variable>
            <xsl:variable name="parentMarcMetadata" select="document($marcMetadataUrl)" />
            
            <xsl:apply-templates select="$parentMarcMetadata//*" mode="marc" />
        </xsl:for-each>
        
        
        <xsl:variable name="lookupParentUri">
            <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host" /><xsl:text>:8080/fedora/risearch?type=tuples&amp;lang=itql&amp;format=Sparql&amp;query=select%20%24parentUri%20from%20%3C%23ri%3E%20%0Awhere%20%3Cinfo%3Afedora%2F</xsl:text>
            <xsl:value-of select="$pid" />
            <xsl:text>%3E%20%3Cinfo%3Afedora%2Ffedora-system%3Adef%2Frelations-external%23isPartOf%3E%20%24parentUri</xsl:text>
        </xsl:variable>
        <xsl:if test="$debug">
            <xsl:comment>
                Querying for related metadata from pid  <xsl:value-of select="$pid" /> using query: <xsl:value-of select="$lookupParentUri" />
            </xsl:comment>
        </xsl:if>
        <xsl:variable name="sparqlResult" select="document($lookupParentUri)" />
        <xsl:variable name="parentPid" select="substring($sparqlResult/s:sparql/s:results/s:result/s:parentUri/@uri, 13)"/>
        <xsl:if test="$parentPid != ''">
            <xsl:if test="$debug">
                <xsl:comment>Pulling metadata from <xsl:value-of select="$parentPid" /></xsl:comment>
            </xsl:if>
            <xsl:variable name="parentMetadataUrl">
                <xsl:text>http://</xsl:text><xsl:value-of select="$fedora-host" /><xsl:text>:8080/fedora/objects/</xsl:text>
                <xsl:value-of select="$parentPid" />
                <xsl:text>/datastreams/descMetadata/content</xsl:text>
            </xsl:variable>
            <xsl:variable name="parentDescMetadata" select="document($parentMetadataUrl)" />
            
            <xsl:for-each select="$parentDescMetadata//node()[starts-with(name(), 'c0')]">
                <field>
                    <xsl:attribute name="name"><xsl:value-of select="name()" /><xsl:text>_pid_display</xsl:text></xsl:attribute>
                    <xsl:value-of select="$parentPid" />
                </field>
            </xsl:for-each>
            <xsl:if test="$parentDescMetadata//ead">
                <field name="collection_pid_display">
                    <xsl:value-of select="$parentPid" />
                </field>
            </xsl:if>
            <xsl:apply-templates select="$parentDescMetadata//*" mode="subsequent" />
            
            <xsl:call-template name="index-parent">
                <xsl:with-param name="pid" select="$parentPid" />
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    
</xsl:stylesheet>
      </foxml:xmlContent>
    </foxml:datastreamVersion>
  </foxml:datastream>
</foxml:digitalObject>
